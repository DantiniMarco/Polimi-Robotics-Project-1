		Project 1_Robotics_2022
		
Prof:
Matteo Matteucci
		
Contributors: 

- D'Antini Marco  - 10603556
- Giamp√† Simone   - 10659184
- Pagano Gabriele - 10578117

indice:
- formule e dove le abbiamo prese
- dati input per odometria 
- calcolo di controllo (inverso)
- dynamic reconfigure
- service set

-------------------------------------------Contents---------------------------------------------------
Our project is made up of two classes: 
- "Odometry.cpp" where we compute the odometry part;
- "Control.cpp" where we compute the control part;

- "Odometry.h" and "Control.h" are header file where all the declarations are made.

- "estimator.py" is a python script that we used to deal with the parameters calibration part.

-------------------------------------------Odometry.cpp-----------------------------------------------

We started searching on the internet the formulas to compute velocities along x, y (vx, vy) and angular velocity (omega) given the wheel velocites (w1, w2, w3, w4) taken from the bags. The following: 

    vx = (w1 + w2 + w3 + w4) * (r / 4.0) / 60.0 / gear_ratio;
    vy = (-w1 + w2 + w3 - w4) * (r / 4.0) / 60.0 / gear_ratio;
    omega = (-w1 + w2 - w3 + w4) * (r / 4.0 / (l + w)) / 60.0 / gear_ratio;

these formulas are corrected for our purposes and unit of measure:
- division by 60.0 to transform [rad/min] to [rad/sec]
- division by gear_ratio to adapt the transmission ratio. 

In particular the wheel velocities are imported from the bags using a ROS subscriber named "sub" (topic "/wheel_states"), then "wheel_state_callback" is called at each new value, so it computes vx, vy, omega using "computeVelocities" function starting from w1, w2, w3, w4;
 
Calling "integrations" we check the method of integration required (between Euler and Runge-Kutta) reading a field in the message set by the parameter reconfigurion and finally compute the odometry, filling up an odom.msg named custom_odometry containing:
 
pose.pose.position
pose.pose.orientration

where the orientations are set up using a quaternion.
These messages are published by a ROS publisher named "pub_odom".
We decided to use a function ("callback_publisher_timer") to publish our messages each time a timer expires.

The function "callback_dynamic_reconfigure" is used to choose the integration method in run-time, so it can switch between Euler and Runke-Kutta.

The callback "callback_set_odometry" instead changes the robot pose reading the Request/Response fields of a Service type message named "set_odometry.srv".

The methods mentioned before are the main functions we used to accomplish the odometry part of the project. Other methods are for utility and test purposes.

In particular we used "optitrack_callback" to verify and confront the shape of the velocitiy plots we calculate with a plot we could have obtained dividing the delta positions (delta_x, delta_y, delta_theta) by the time of sampling. 
This plot was firstly too noisy, so we used an average each 100 samples using a vector. 
Building and publishing "test_msg" message, we plotted it in PlotJuggler realizing that it was correct. 

A similar modality was made in "encoder_ticks_callback" where we show the velocity plot using the ticks instead of RPM. With the same method of 100 samples average measurement we filled up and published a "tick_msg" message in order to visualize it in PlotJuggler. 
Observing a much higher noise shape of the plot, we decided too keep using the RPM data for our odometry.

At this point of the project we started thinking on the parameters calibration part, so we decided to develop a Python script in which we compute again the odometry, but this time with the possibility to change and iterate on the required parameters with the aim of calculate an error function. 
In order to do this we needed to record a new bag containing the wheels velocities (RPM) and the robot pose, but this time synchrously. In fact we noticed that the Stamp was different between the two measurements. That's what "record_callback" is for. It publishes a new message "record.msg" through "pub_record" ROS publisher. 
We finally recorded this Stamp synchronized new bag using rosbag record. 

-------------------------------------Control.cpp-----------------------------------------------------

The basic idea is to develop a reverse computation starting from the robot velocities vx, vy, omega to obtain the wheel velocities. In order to do that we searched formulas on the internet that are the following: 
	
    w1 = ((-(l + w) / r) * omega + vx / r - vy / r) * k;
    w2 = (((l + w) / r) * omega + vx / r + vy / r) * k;
    w3 = ((-(l + w) / r) * omega + vx / r + vy / r) * k;
    w4 = (((l + w) / r) * omega + vx / r - vy / r) * k;
    
We multiply per k = 60 * gear_ratio / 2 * pi to obtain the correct unit of measure that is [rad/sec].

These are the steps: 
 
1) subrscription with a ROS subscriber "sub" to the "/cmd_vel" topic. This is the topic that we publish in the previous step;

2) at each new data the "wheel_velocities_callback" function is called. Here we take the values vx, vy, omega from from the message;

3) "computeOmega" function is called to compute the angular velocities with the actual values;

4) a custom message "omega_msg" is published containing the values w1, w2, w3, w4 using the ROS publisher "pub" at timer interval;

Observing on PlotJuggler the plot of our velocities and the velocities of the bags, we made sure that the two plots were similar. 

 




 


 




 


